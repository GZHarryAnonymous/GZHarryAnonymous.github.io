<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[41. First Missing Positive]]></title>
    <url>%2F2019%2F02%2F01%2FLeetCode_40%2FLeetCode_41%2F</url>
    <content type="text"><![CDATA[题目：41. First Missing Positive问题描述： 给定一个无序的整形数组。 找到缺失的最小整形。 Input: [7,8,9,11,12] Output: 1 题目分析： 重复情况的考虑 边界判断 求解方法： 先排序后遍历 算法思想： 双中心快排 知识点扩展：总结感悟：相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30. Substring with Concatenation of All Words]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_30%2F</url>
    <content type="text"><![CDATA[题目：30. Substring with Concatenation of All Words问题描述： 给定一个字符串和一个字符串数组。 字符串数组中每一个单词长度相同（字符个数一样）。 查看字符串中是否存在子串刚好由所有单词组成。 如果存在返回下标。 举例： Input: s = “barfoothefoobarman”, words = [“foo”,”bar”] Output: [0,9] 题目分析：求解方法： 滑动窗口 算法思想： s = “barfoothefoobarman” words = [“foo”,”bar”]words中的word长度是相同的。 words中的单词是可以重复出现的。比如：words = [“foo”,”bar”,”foo”] s中存在words中的组合。 首先每回走一个字符在s中，然后用hashMap记录words中特定单词出现的次数。 但此种方法效率低下。 或者，每回走一个word，走word.length()回，这样就可以重复利用啦！ 只需要考虑新进的单词和后加的单词的差异，借助之前的分析。 详解见代码。 知识点扩展：总结感悟：相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[29. Divide Two Integers]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_29%2F</url>
    <content type="text"><![CDATA[题目：29. Divide Two Integers问题描述： 位运算实现加减乘除 题目分析：求解方法：算法思想：知识点扩展：总结感悟：相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[28. Implement strStr()]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_28%2F</url>
    <content type="text"><![CDATA[题目：28. Implement strStr()问题描述： Input: haystack = “hello”, needle = “ll” Output: 2 Input: haystack = “aaaaa”, needle = “bba” Output: -1 返回第一个匹配的模式子串的下标 题目分析：求解方法： Just do it! KMP 算法思想： 以每一个字符作为字符串的开始字符进行判断，判断过程可以先预判模式串的最后一个字符是否匹配，避免唯有最后字符不匹配的情况，前面的匹配就白玩了。 KMP算法的核心思想是利用模式串的重复部分，比如abab是模式串，主串是abacabc，那么当模式串的第二次出现的b字符与主串的第一次出现的c字符相遇时，c与b不等，那么模式串直接回退到第一个a，因为对于模式串自身而言，ab与ab是相等的，而主串是无需回退的。 知识点扩展：总结感悟：相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[27. Remove Element]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_27%2F</url>
    <content type="text"><![CDATA[题目：27. Remove Element问题描述： 移除给定整形数组中指定的元素并返回新数组元素个数。无需顾忌新数组元素以外的元素空间如何使用。 题目分析：求解方法： 双头 算法思想： Just do it! 知识点扩展：总结感悟：相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[26. Remove Duplicates from Sorted Array]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_26%2F</url>
    <content type="text"><![CDATA[题目：26. Remove Duplicates from Sorted Array问题描述： 去除给定整形有序数组的重复元素。并返回新数组的元素个数。 必须在给定数组上进行操作。 假设新数组长度为n，那么前n个元素各不相同且无需关注新数组n个元素之后的值如何。 题目分析：求解方法：算法思想： 利用有序性质，变量index记录不重复的数组长度（即新数组有效范围），遍历数组元素，若与当前num[index]不等，则加入有效数组。index始终记录有效数组的末端元素。因为有序，所以下一个出现的重复元素一定是和num[index]相等的情况。 知识点扩展：总结感悟：相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[25. Reverse Nodes in k-Group]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_25%2F</url>
    <content type="text"><![CDATA[题目：25. Reverse Nodes in k-Group问题描述： 给定一个链表，K临近节点反转。 Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 题目分析： 审题很重要，比如此题的step不够不予以处理。即：k=3情况，4和5不予处理。 不可以链表节点不动仅仅交换值，应该移动链表的结构达到交换。 求解方法： 递归，链表n步长倒置。 算法思想：知识点扩展：总结感悟： 递归方法编程过程中边界条件应该先确定。 及时返回以绝后患是优化的可能之一。 相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[24. Swap Nodes in Pairs]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_24%2F</url>
    <content type="text"><![CDATA[题目：24. Swap Nodes in Pairs问题描述： Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 相邻节点两两相换。 题目分析：求解方法： 交换相邻链表可以按照逻辑走，可以递归。 算法思想： 但也可以只换值，不换链表结构。 知识点扩展：总结感悟：相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23. Merge k Sorted Lists]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_23%2F</url>
    <content type="text"><![CDATA[题目：23. Merge k Sorted Lists问题描述： 多路链表归并 题目分析：求解方法：-多路归并 算法思想： 每次二路，设置interval*=2； 知识点扩展：总结感悟：相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[22. Generate Parentheses]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_22%2F</url>
    <content type="text"><![CDATA[题目：22. Generate Parentheses问题描述： Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] 题目分析：求解方法： 暴力求解 回溯 闭包数 算法思想： pow(2,2n)种可能中逐一判别。 其实就是一棵树，不过生长方式有限定，left(open)能生长就生长，但要满足open_num&lt;=n。right(close)能生长就生长，但要保证close_num&lt;=n且close_num&lt;=open_num。open在前close在后。最后从根节点到每一个叶节点的路径都是一种合理的可能。 如果n=1，那么一定是”()”情况。我们假设generate(j)可以生成左右括号个数都为j的所有合理情况。那么现在:”(“+”generate(i)的所有合理情况”+”)”+”generate(n-1-i)的所有合理情况”当i从0取到n-1时，就是穷尽所有可能之日。有点数学归纳法的感觉。 知识点扩展： 有HashSet和TreeSet都实现了Set接口。 HashSet由于是集合，所以元素不可以重复，即便是null只能有一个，查找元素的过程是首先计算对象的HashCode值，然后通过HashCode值直接对应到存储该对象的区域调用equals方法进行查找，从而提高了效率。 Object的equals方法是根据两个对象的内存地址判断两个对象是否相等。所以Set插入Object时，需要重写equals方法，进一步区分内存地址不同但内容相同的“相同”对象。 // 覆写equals方法 public boolean equals (Object obj){ // 地址相等，则肯定是同一个对象 if(this==obj){ return true; } // 类型不同，则肯定不是同一类对象 if(!(obj instanceof Person)){ return false; } // 类型相同，向下转型 Person per=(Person) obj; // 如果两个对象的姓名和性别相同，则是同一个人 if(this.name.equals(per.name)&amp;&amp;this.sex.equals(per.sex)) return true; return false; } 当然为了保证不同对象有不同的内存地址，需要重写hashCode方法 // 覆写hashCode方法 public int hashCode(){ return this.name.hashCode();//name相当于主键哦！ } 而TreeSet可以自定义Comparator对插入的元素进行相应的排序。 与HashSet完全类似，TreeSet里面绝大部分方法都市直接调用TreeMap方法来实现的。 相同点： TreeMap和TreeSet都是有序的集合，也就是说他们存储的值都是排好序的。 TreeMap和TreeSet都是非同步集合，因此他们不能在多线程之间共享，不过可以使用方法。 Collections.synchroinzedMap()来实现同步。 运行速度都要比Hash集合慢，他们内部对元素的操作时间复杂度为O(logN)，而HashMap/HashSet则为O(1)。 不同点： 最主要的区别就是TreeSet和TreeMap分别实现Set和Map接口。 TreeSet只存储一个对象，而TreeMap存储两个对象Key和Value（仅仅key对象有序） TreeSet中不能有重复对象，而TreeMap中可以存在。 TreeMap&lt;K,V&gt;是有序的Map，底层使用了红黑树这种数据结构来实现。红黑树是一种应用非常广泛的树结构，在这里先简单说下红黑树这种数据结构相比较其他树类型结构的优缺点：红黑树是一种自平衡的二叉查找树，也叫对称二叉B树，红黑树的查找、插入和删除的时间复杂度都为O(logn)，应用非常广泛。红黑树相对于AVL树（平衡二叉树），牺牲了部分平衡性（红黑树不是完全平衡的二叉树）以换取插入/删除操作时更少的旋转操作，整体在插入/删除的性能上要优于AVL树。所以很多在内存中排序的数据结构都使用红黑树来而不是使用AVL树来存储。红黑树相对于B-树和B+树，相同节点的情况下红黑树由于深度比B-和B+树要深的多，对IO读写非常频繁，所以适合放在内存中的少量读取，而B-和B+树由于每个节点元素非常之多，访问IO的次数就相对少，适合存储在磁盘中的大量数据，类似数据库记录的存储结构。 总结感悟：相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21. Merge Two Sorted Lists]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_21%2F</url>
    <content type="text"><![CDATA[题目：21. Merge Two Sorted Lists问题描述： 链表二路归并 题目分析：求解方法： 二路归并 可以用递归，但空间复杂度更高。 算法思想：知识点扩展：总结感悟：相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20. Valid Parentheses]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_20%2F</url>
    <content type="text"><![CDATA[题目：20. Valid Parentheses问题描述： Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. 题目分析： An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. 求解方法： 可以运用堆栈，也可以运用递归。 算法思想： 后进先出 知识点扩展：总结感悟： C++写算法，越接近底层，自己实现的越彻底，往往节约逻辑运算。 有时候自己可以在输入参数中添加一些字符，起到辅助的作用。 相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19. Remove Nth Node From End of List]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_19%2F</url>
    <content type="text"><![CDATA[题目：19. Remove Nth Node From End of List问题描述： 求给定链表移除倒数(从尾部开始数)第n个节点后的新链表。 题目分析： n=1表示移除最后一个节点。 求解方法： 双头 算法思想： Maintain two pointers and update one with a delay of n steps. 前赴后继，隔了step，你追我敢。 知识点扩展：总结感悟： 逻辑上的最优只适用于更普遍意义上的测试用例。 针对不同的测试用例分布状况，应该选取不同的逻辑结构。 相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18. 4Sum]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_18%2F</url>
    <content type="text"><![CDATA[题目：18. 4Sum问题描述： 给定一个数组和目标值，求元素之和等于目标值的所有子数组(包含4个元素)。 题目分析： 结果集为set，不允许重复。 求解方法：算法思想： 使得序列有序 然后遍历，每次选择一个数，用目标值减之，得到targetNew 然后求解3数之和等于targetNew 参考3数之和方法(targetNew-currentNum==left+right) 数组有序的好处是比较target=left+right时，不够left++，多了right–，将求两数之和控制在O(n).当然，在求解两数之和的过程中也可以采用二分法进一步优化。 知识点扩展：总结感悟： 一些极端情况的考虑排查看似无关紧要，却往往能够立刻排除无用的数据。 通常情况下，越优的程序，再优化越难，优化后改善的程度越小，但越加可贵。 优化过程也是有成本的，如果优化代价大于优化后所得增益，那么就只能说想法是好的，但不可行。 平台的测试用例可能会变。 相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17. Letter Combinations of a Phone Number]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_17%2F</url>
    <content type="text"><![CDATA[题目：17. Letter Combinations of a Phone Number问题描述： 计算器(3乘以3)，1不映射。2映射（abc），3映射（def）以此类推，9映射（wxyz）。 给定”23” 输出[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”] 题目分析：求解方法： 递归 算法思想： 每一次递归取一个数字对应的字母串进行遍历，并将其与上一层的字符串拼接。 最终递归过程实现了一棵树，每一层都是上一层针对下一个字母串的延拓。 root根节点，下一个字母串(abc) a b c树的第一层，下一个字符串(def) ad ae af bd be bf cd ce cf …… 知识点扩展： 如果if能解决，就不要加else。 总结感悟： 一生二，二生四，。。。。有点易经的味道，树结构是真的不简单！ 相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16. 3Sum Closest]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_16%2F</url>
    <content type="text"><![CDATA[题目：16. 3Sum Closest问题描述： 给定一整形数组，求其所有元素和为指定数值的子数组（仅含3个元素）。 当不存在子数组元素和满足指定值的时候，返回离指定数值最近的情况下的子数组。 题目分析：求解方法：算法思想： 使得序列有序 然后遍历，每次选择一个数 另外两个left=i+1，right=len-1 算法复杂度O(n^2)级别。 知识点扩展：总结感悟：相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15. 3Sum]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_15%2F</url>
    <content type="text"><![CDATA[题目：15. 3Sum问题描述： 给定一整形数组，求其所有元素和为零的子数组（仅含3个元素）。 题目分析：求解方法：算法思想： 使得序列有序 然后遍历，每次选择一个数 另外两个left=i+1，right=len-1 算法复杂度O(n^2)级别。 知识点扩展： JDK7开始Arrays.sort(nums);的内部实现已经由经典的快排改为 Dual-Pivot Quicksort算法。该双中心快排顾名思义，比经典快排多了一个Pivot，数据被分成3段。其元素比较次数多于经典快排。但整体速度占优。 Memory Wall内存墙：由于CPU发展速度快于内存，联想短板（木桶）效应，影响计算速度的瓶颈是内存，而非CPU。所以算法的评测需要考虑CPU与内存的交互程度（少好）。 Dual-Pivot快排比经典快排节省12%的元素扫描，从实验来看节省10%的时间。 总结感悟： 综合因素才能有效评测。 相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14. Longest Common Prefix]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_14%2F</url>
    <content type="text"><![CDATA[题目：14. Longest Common Prefix问题描述： LCP:给定字符串数组，求其内部各个字符串间公共最长前缀子串。 题目分析：求解方法： 水平扫 纵向扫 分治（递归） 二分查找 Trie(字典树) 算法思想： 字符串数组可能有多个字符串元素，两两比对（1和2比，再2和3比，，，），随着比较的深入，公共最长子串会越来越小。简约：咱俩先比较得出都有双眼皮，然后再看看他有没有双眼皮，进一步判断3个人的共同点。 一个字符一个字符的筛选，你有我有全都有，再红红火火往下走。 感觉就像水平扫引入二路归并，树形结构自行脑补。 有点纵向扫引入二分查找的赶脚，也是一棵树，自行脑补。 每个节点都是一个字符，一个字符串是一条树（没有分支），多个字符串合并就是一棵树（根朝天），树干就是公共子串。 知识点扩展： StringBuilder是非线程安全的。 StringBuffer是线程安全的，内部方法有使用synchronized修饰。 由于StringBuilder没有同步锁机制，所以单线程情况下效率更高。 总结感悟： 一题多解。思维短练。 相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13. Roman to Integer]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_13%2F</url>
    <content type="text"><![CDATA[题目：13. Roman to Integer问题描述： 罗马数字转阿拉伯数字 阿拉伯数字与罗马数字关系(I:1,V:5,X:10,L:50,C:100,D:500,M:1000) 左减右加原则(IV=5-1=4,IX=10-1=9,LVIII=50+5+3=58) VIII=8没问题，但是VIIII是不能表示9的，应该是IX=9.同理有IV=4,XL=40,CD=400,CM=900 题目分析： 1994=1000+(1000-100)+(100-10)+(5-1)=MCMXCIV 求解方法： MCMXCIV=1000+(1000-100)+(100-10)+(5-1)=1994 算法思想： 当前小于后一个则减去当前值，当前大于后一个则加上。 逻辑中的switch case可以使用HashMap代替进一步优化。 知识点扩展： 字符串遍历： s=&quot;abc&quot; for(int i=0;i&lt;s.length();i++){ System.out.println(s.charAt(i));} 不可到达的代码不要写 return 0; break; //This Line: error: unreachable statement 字符串数组： String[] s1={&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;}; for(int i=0;i&lt;s1.length;i++){ System.out.print(s1[i]+&quot; &quot;);//输出a b c d e，获取字符串数组 } String[] s2={&quot;abcde&quot;}; System.out.println(s2.length);//输出1，只是长度为1的数组，并不是5 for(int i=0;i&lt;s2.length;i++){ System.out.print(s2[i]+&quot; k&quot;);//输出abcde k } 总结感悟：相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12. Integer to Roman]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_12%2F</url>
    <content type="text"><![CDATA[题目：12. Integer to Roman问题描述： 阿拉伯数字转罗马数字 阿拉伯数字与罗马数字关系(I:1,V:5,X:10,L:50,C:100,D:500,M:1000) 左减右加原则(IV=5-1=4,IX=10-1=9,LVIII=50+5+3=58) VIII=8没问题，但是VIIII是不能表示9的，应该是IX=9.同理有IV=4,XL=40,CD=400,CM=900 题目分析： MCMXCIV=1000+(1000-100)+(100-10)+(5-1)=1994 求解方法： 1994=1000+(1000-100)+(100-10)+(5-1)=MCMXCIV 算法思想： 按照限定条件完成相关逻辑。 知识点扩展： 减法比取余快。 总结感悟：相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11. Container With Most Water]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_11%2F</url>
    <content type="text"><![CDATA[题目：11. Container With Most Water问题描述： 给你一个非负的数组，数组下标代表横轴位置，数组值代表竖轴位置，请自行脑补平面二维直角坐标系。接下来将横轴想象成地面、竖轴想象成隔板，如何选取其中的两个隔板使得其与地面构成的容器盛水最多。 题目分析： 容器的高由选取的两个竖轴中较短的一边决定。（木桶效应） 求解方法： 暴力求解 两边靠 算法思想： 穷举所有可能，比较得出最大值。 面积的乘积由长和宽两方面构成。所以应该是两边并向中间的过程中筛选。两边往中间走，最终的状态一定是两边中的某两个点(隔板)被选中。左右情况是对等的(隔板A+隔板B等价于隔板B+隔板A)。靠拢的过程是每次舍弃当前被选中隔板中较短的一方。所以重合之时就是所有更大可能穷尽之日。 知识点扩展：总结感悟： 题解的思路通常决定算法的性能。 相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10. Regular Expression Matching]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_10%2F</url>
    <content type="text"><![CDATA[题目：10. Regular Expression Matching问题描述： 字符串匹配问题 题目分析： text与pattern字符串匹配(完全等价，对等的地位，不是部分的关系) text为a-z pattern为a-z . * .匹配任意单个字母 X*可以是0个或者多个X .*匹配任意，可以理解为任意多个点 …… 原字符与匹配字符 求解方法： 递归 动态规划 算法思想： 简单分析如果没有*通配符的情况 dp(i,j)-&gt;dp(i+1)(j+1) 递归处理，空，点，按规则（匹配当前或者匹配下一个）一步一步往下走，剩下一个字符在递归开始的地方处理。 考虑所有情况： dp(i,j)-&gt;dp(i+1)(j+1)当.*代表一个 dp(i,j)-&gt;dp(i)(j+2)当.*代表空 dp(i,j)-&gt;dp(i+1)(j)当.*代表多个 动态规划是空间换时间，保存中间状态结果。 还有自底向上的动态规划。 知识点扩展： 注意：”hamburger”.substring(4, 8) returns “urge”4是开始下标，7是结束下标。 八大基本数据类型的默认值： boolean false char ‘/uoooo’(null) byte (byte)0 short (short)0 int 0 long 0L float 0.0f double 0.0d 布尔数组没有赋值也一样。 总结感悟：相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9. Palindrome Number]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_9%2F</url>
    <content type="text"><![CDATA[题目：9. Palindrome Number问题描述： 给定数字判别回文 题目分析： 判别回文整形 整个数取反可能会大于int.MAX。 求解方法： 不使用字符串。 可以取后半段和前半段比较。 算法思想：知识点扩展： pow函数与sqrt函数的返回值为double型。 总结感悟： 合理的方案比实施更重要。 想清楚再做。 相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8. String to Integer (atoi)]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_8%2F</url>
    <content type="text"><![CDATA[题目：8. String to Integer (atoi)问题描述： 字符串转整形对象 题目分析： ‘ ‘过 遇到第一个非空格且非数字，停 超过INT_MAX或者超过INT_MIN，返回INT_MAX或者超过INT_MIN 若第一个非空格且非数字，返回0 求解方法： 可以将字符串中字符转化为整形的类型 Integer.parseInt(str.substring(i,i+1)) str.charAt(i)-‘0’ 算法思想：知识点扩展： java中没有typeof 只有instanceof java中要使用反射：str.getClass()判别类类型 char是基本数据类型，两个字节，底层存储为Unicode字符集 Character是char的包装类，其可以调用getClass()等方法 基本数据类型是没有方法的 总结感悟：相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7. Reverse Integer]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_7%2F</url>
    <content type="text"><![CDATA[题目：7. Reverse Integer问题描述： 32-bit signed Integer 反转 123变321，-123变-321，120变21 题目分析： 2^31-1=2147483647=Integer.MAX_VALUE -2^31=-2147483648=Integer.MIX_VALUE 判别溢出： 对于上界2147483647 当前大于等于INTMAX/10，则： 当前大于，则下一步溢出。 当前等于，则下一步比较个位是否大于7。 求解方法： 字符反转 题解有使用栈结构的。 算法思想： 变成字符串，倒序。 后进先出。 知识点扩展：总结感悟：相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6. ZigZag Conversion]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_6%2F</url>
    <content type="text"><![CDATA[题目：6. ZigZag Conversion问题描述： P A H N A P L S I I G Y I R 上面的字符按竖着的Z型读取得到字符串”PAYPALISHIRING” 现在给你这个字符串，和上面的图的行数（当前行数为3） 请你一行一行的输出：”PAHNAPLSIIGYIR” 题目分析：求解方法： Z型遍历，一个一个分别存储到numRows个StringBuilder中，空间复杂度高。 算法思想： 下标规律分析 知识点扩展：总结感悟： 在纸上分析规律是要尽量清晰，书写工整。 边界条件的测试很重要。 相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5. Longest Palindromic Substring]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_5%2F</url>
    <content type="text"><![CDATA[题目：5. Longest Palindromic Substring问题描述： 查找给定字符串的最长回文子串。 Example 1: Input: “babad” Output: “bab” Note: “aba” is also a valid answer. 题目分析： 回文字符串左右对称。是自对称哦！ 求解方法： 动态规划 由内而外扩充 Manacher 算法思想： 单个字符自对称,p(i,i)=true;if(Si==Si+1)p(i,i+1)=true;p(i,j)=(p(i+1,j-1)andSi==Sj) 当前字符视为可能存在的最长回文字符串的中心。将每一个字符作为中心，向两边扩展。同时要考虑两个字符同时作为中心的情况。2n-1个字符需要考虑。 Manacher:插入字符避开两个相同的挨着，从左到右计算p[i]值用max_right_node覆盖区域找当前点的对等点，利用已知求未知。 知识点扩展： 边界条件的判断。 具体方法的抽象与封装。 char类型比较内容 == substring(int start,int end)是start到end-1 总结感悟： 当分析下标时无法确定其规律，可以自己举例验证，实际的例子比抽象的想象更容易。 相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4. Median of Two Sorted Arrays]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_4%2F</url>
    <content type="text"><![CDATA[题目：4. Median of Two Sorted Arrays问题描述： 求两个有序数组合并后的中位数。 题目分析： 偶数个除以二。 给定数组各自有序。 求解方法： 中位数的定义理解 二路归并 算法思想： 从中位数的定义着手：中位数把数列分为个数相等的两半，且右边最小的大于等于左边最大的。我们可以先满足条件一（左右两边个数相等），将数组A和B各自等分，再进一步调整使得数列在保证条件一的前提下，满足条件二。 直接二路归并找中位数，当已归并的数列达到两个数列总和的一半时就找到啦！ 知识点扩展：总结感悟： 看似应该是方法一更快一些，但不同测试用例的具体情况还要具体分析。 相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3. Longest Substring Without Repeating Characters]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_3%2F</url>
    <content type="text"><![CDATA[题目：3. Longest Substring Without Repeating Characters问题描述： 给定一字符串，求最长无重复子串。 Example 1: Input: “abcabcbb” Output: 3 Explanation: The answer is “abc”, with the length of 3. 题目分析： 子序列可以不连续，但子串必须连续。 无重复。 求解方法： 暴力破解：遍历每一个子串，通过定义一个函数用于确定当前子串是否有重复的字符。 滑动窗口：构建变量i和j记录子串的始末下标：i，j分别是两个指向，j先一步一步向前走，如果j重复了，则i走一步。始终关注的点是i到j这个区间的最长无重复子串。进一步的优化，如果j和i到j区间的某一个k点重复了，则i可以直接跨步到k+1。 算法思想： 滑动的窗口是一个形象的比喻，或者你可以把i到j想象成是橡皮筋的两端，不重复是橡皮筋弹性拉伸的前提，而回弹的步长可以是一步一个脚印，但也可以跨步向前。具体问题具体分析。 在实践过程中，有一个很重要的点就是将字符与其对应下标进行一一映射，而关联的方法不唯一：可以采用HashMap、HashSet和ASCII（int[] index = new int[128];数组的下标对应字符的ASCII，而数组值对应字符在字符串中的位置下标）. 知识点扩展： 依赖倒置原则：依赖抽象，不依赖具体，所以变量声明可以用Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); HashMap中使用的泛型需要是包装类，不可以是基本数据类型。因为基本数据类型没有继承Object类，没有方法，当然也无法调用hashcode()方法和equals()方法。而包装类是继承Object类的。 特别的，当HashMap存储自定义对象的时候，需要按照自己的需求重写hashcode()和equal()方法。否则，每new一次就创建一个新的对象，面对相同对象（仅引用不同）的情况，导致HashMap存储重复值。详解见hashcode源码。 HashMap实现Map接口，存储键值对，使用put和get方法，使用key计算hashcode值，速度稍快。 HashSet实现Set接口，仅存储对象，使用add和remove方法，使用成员对象计算hashcode，速度稍慢。 相关源码如下： public boolean equals(Object obj) { return (this == obj); } public boolean equals(Object o) { if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o; if (m.size() != size()) return false; try { Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) { Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) { if (!(m.get(key)==null &amp;&amp; m.containsKey(key))) return false; } else { if (!value.equals(m.get(key))) return false; } } } catch (ClassCastException unused) { return false; } catch (NullPointerException unused) { return false; } return true; } 总结感悟： Java的好处是封装，而且有人帮你封装，你可以直接用一些方法。坏处是被封装的方法不是你自己写的。 相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2. Add Two Numbers]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_2%2F</url>
    <content type="text"><![CDATA[题目：2. Add Two Numbers问题描述： 两个非空链表，逆序存储，相加。 Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. 题目分析： 尾部元素相加应该放在头部。 有进位。 求解方法： Just do it! 算法思想： 尾摘头插，设置中间变量用于记录进位。 知识点扩展： 运算符的使用，简化代码。int x = (p != null) ? p.val : 0; 总结感悟： 代码简洁很重要！！！ 相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.Two Sum]]></title>
    <url>%2F2019%2F01%2F20%2FLeetCode_1-30%2FLeetCode_1%2F</url>
    <content type="text"><![CDATA[题目：1. Two Sum问题描述： 确定一给定数组中存在两数相加得到指定数值。 数组中元素不可重复使用，若解存在则唯一。 题目分析： 注意限制条件。 求解方法： 暴力破解。 通过HashMap将数组值与下标进行关联。在关联过程中直接判断：Map.contains(target-currentElement) 算法思想： 在关联过程中直接判断：map.contains(target-currentElement)的可行性在于： 每一次新加入的元素都会与map中已有的元素进行比较，如下： 1,2,3,4…… (1,2) (1,3),(2,3) (1,4),(2,3),(3,4) …… 知识点扩展： HashMap的存储结构是数组(散列桶)+链表 HashMap的get方法返回null时有两种情况:getNode(hash(key),key)==null 或者 getNode(hash(key),key)!=null但是e.value==null(value可以put为空值) containsKey(Object key)通过判别getNode(hash(key),key)的返回值来确定key值的存在性。 在更新1.8版本之后，结点数量达到8个将链表转为红黑树。少于6个则使用链表。 源码如下: public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } public boolean containsKey(Object key) { return getNode(hash(key), key) != null; } 总结感悟： 程序=数据结构+算法，该题解的思路关键在于数据结构（HashMap）的运用。 HashMap中hashCode的计算方法有许多数学机理，感兴趣的自行了解。 相关说明： 基于LeetCode平台算法的一个刷题记录！ 已经共享至public repository：仓库链接 欢迎题友们fork、push纠正相关错误、交流相关问题！(别忘了给颗星哦！) 个人博客：GZHarryAnonymous 欢迎来访！当然，如果来访还打赏就更好啦！！！ 能力有限，希望有帮到你！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
</search>
